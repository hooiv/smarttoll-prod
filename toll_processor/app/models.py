import time as _time
from pydantic import BaseModel, Field, field_validator
from typing import Optional, Dict, Any
import uuid


class GpsData(BaseModel):
    """Represents incoming GPS data message structure."""
    deviceId: str = Field(..., description="Unique identifier of the OBU device")
    vehicleId: str = Field(..., description="Identifier of the vehicle (e.g., license plate)")
    timestamp: int = Field(..., description="Epoch timestamp in milliseconds (UTC)")
    latitude: float = Field(..., ge=-90, le=90, description="GPS latitude")
    longitude: float = Field(..., ge=-180, le=180, description="GPS longitude")
    speedKmph: Optional[float] = Field(None, ge=0, description="Speed in kilometers per hour")
    heading: Optional[float] = Field(None, ge=0, le=360, description="Direction of travel in degrees")
    altitudeMeters: Optional[float] = Field(None, description="Altitude in meters")
    gpsQuality: Optional[int] = Field(None, ge=0, description="Indicator of GPS fix quality (e.g., satellite count)")

    @field_validator('timestamp')
    @classmethod
    def timestamp_must_be_positive(cls, v: int) -> int:
        if v <= 0:
            raise ValueError('Timestamp must be a positive epoch milliseconds value')
        return v

    @field_validator('timestamp')
    @classmethod
    def timestamp_must_be_recent(cls, v: int) -> int:
        """Reject GPS messages that are stale (>10 min old) or from the future (>60 s ahead).

        Stale messages could cause incorrect zone-entry/exit accounting since the
        toll processor uses the GPS timestamp for entry/exit times.
        """
        now_ms = int(_time.time() * 1000)
        max_age_ms = 10 * 60 * 1000   # 10 minutes
        max_future_ms = 60 * 1000     # 60 seconds
        if v < now_ms - max_age_ms:
            raise ValueError(
                f'GPS timestamp is too old: {(now_ms - v) / 1000:.0f}s ago (max 10 minutes)'
            )
        if v > now_ms + max_future_ms:
            raise ValueError(
                f'GPS timestamp is in the future: {(v - now_ms) / 1000:.0f}s ahead (max 60 seconds)'
            )
        return v


class VehicleState(BaseModel):
    """Represents the state of a vehicle stored in Redis."""
    in_zone: bool
    zone_id: str
    rate_per_km: float
    entry_time: int  # Epoch ms
    distance_km: float = 0.0
    lat: float
    lon: float
    last_update: int  # Epoch ms of the last update
    deviceId: str


class TollEvent(BaseModel):
    """Represents the calculated toll event published to Kafka."""
    eventId: str = Field(default_factory=lambda: str(uuid.uuid4()),
                         description="Unique identifier for this toll event")
    vehicleId: str
    deviceId: str
    zoneId: str
    entryTime: int  # Epoch ms
    exitTime: int   # Epoch ms
    distanceKm: float
    ratePerKm: float
    tollAmount: float
    currency: str = "USD"
    processedTimestamp: int  # Epoch ms when the event was generated by the processor


class ErrorMessage(BaseModel):
    """Structure for messages sent to the error topic."""
    service: str = "toll_processor"
    error_type: str
    message: str
    traceback: Optional[str] = None
    original_message: Optional[Dict[str, Any]] = None
    context: Optional[Dict[str, Any]] = None
