from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any
import uuid

class GpsData(BaseModel):
    """Represents incoming GPS data message structure."""
    deviceId: str = Field(..., description="Unique identifier of the OBU device")
    vehicleId: str = Field(..., description="Identifier of the vehicle (e.g., license plate)")
    timestamp: int = Field(..., description="Epoch timestamp in milliseconds (UTC)")
    latitude: float = Field(..., ge=-90, le=90, description="GPS latitude")
    longitude: float = Field(..., ge=-180, le=180, description="GPS longitude")
    speedKmph: Optional[float] = Field(None, ge=0, description="Speed in kilometers per hour")
    heading: Optional[float] = Field(None, ge=0, le=360, description="Direction of travel in degrees")
    altitudeMeters: Optional[float] = Field(None, description="Altitude in meters")
    gpsQuality: Optional[int] = Field(None, ge=0, description="Indicator of GPS fix quality (e.g., satellite count)")
    # Add any other relevant fields from the OBU

    @validator('timestamp')
    def timestamp_must_be_positive(cls, v):
        if v <= 0:
            raise ValueError('Timestamp must be a positive epoch milliseconds value')
        # Add check for reasonable time range?
        return v

class VehicleState(BaseModel):
    """Represents the state of a vehicle stored in Redis."""
    in_zone: bool
    zone_id: str
    rate_per_km: float
    entry_time: int # Epoch ms
    distance_km: float = 0.0
    lat: float # Last known valid position inside zone
    lon: float
    last_update: int # Epoch ms of the last update
    deviceId: str # Store device ID associated with this state entry

class TollEvent(BaseModel):
    """Represents the calculated toll event published to Kafka."""
    eventId: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique identifier for this toll event")
    vehicleId: str
    deviceId: str
    zoneId: str
    entryTime: int # Epoch ms
    exitTime: int # Epoch ms
    distanceKm: float
    ratePerKm: float
    tollAmount: float
    currency: str = "USD" # Could be part of zone config
    processedTimestamp: int # Epoch ms when the event was generated by the processor

class ErrorMessage(BaseModel):
    """Structure for messages sent to the error topic."""
    service: str = "toll_processor"
    error_type: str # e.g., "ValidationError", "DatabaseError", "ProcessingLogicError"
    message: str
    traceback: Optional[str] = None
    original_message: Optional[Dict[str, Any]] = None # The message that caused the error
    context: Optional[Dict[str, Any]] = None # Additional context (e.g., vehicleId, state)
